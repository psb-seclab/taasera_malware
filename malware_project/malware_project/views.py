from django.shortcuts import render
from django.template import RequestContext
from django.shortcuts import render_to_response
from django.contrib.auth.models import User
from django.contrib.auth import authenticate, login, logout
from django.contrib.auth.decorators import login_required
from django.http import HttpResponseRedirect, HttpResponse
from django.contrib import messages
from django.core.mail import send_mail
from django.conf import settings

from forms import CaptchaTestForm
from malware.models import Malware, Family

import os

class Chart:
    def __init__(self, chart_type, data, name, title):
        self.chart_type = chart_type
        self.data = data
        self.name = name
        self.title = title
        self.make_script()


    def make_script(self):
        self.script = "\
        google.setOnLoadCallback(%s);\n \
        function %s() { \n \
            // Create the data table.\n \
            var data = new google.visualization.DataTable();\n \
            data.addColumn('string', 'Topping');\
            data.addColumn('number', 'Slices');\
            data.addRows(%s);\n \
            // Set chart options\n \
            var options = {'title':'%s',\n \
                           'width':400,\n \
                           'height':300};\n \
            // Instantiate and draw our chart, passing in some options.\n\
            var chart = new google.visualization.%s(document.getElementById('%s'));\n\
            chart.draw(data, options);\n\
          }\
        "%(self.name, self.name, str(self.data), self.title, self.chart_type, self.name)
        #print self.script


def index(request):
    # test cookie
    #request.session.set_test_cookie()
    # Obtain the context from the HTTP request.
    context = RequestContext(request)
    # Query the database for a list of ALL categories currently stored.
    # Order the categories by no. likes in descending order.
    # Retrieve the top 5 only - or all if less than 5.
    # Place the list in our context_dict dictionary which will be passed to the template engine.
    context_dict = {
    }
    # Render the response and send it back!
    return render_to_response('index.html', context_dict, context)


def about(request):
    # test cookie
    #request.session.set_test_cookie()
    # Obtain the context from the HTTP request.
    context = RequestContext(request)
    
    context_dict = {
    }

    # Render the response and send it back!
    return render_to_response('about.html', context_dict, context)


def get_data_by_date(dd):
    tmp_list = Malware.objects.all().values("honeypot").distinct()
    

def get_date_by_month(mm):
    tmp_list = Malware.objects.all().values("honeypot").distinct()


# Use the login_required() decorator to ensure only those logged in can access the view.
@login_required
def stats(request):
    context = RequestContext(request)
    context_dict = {
    }

    #########################################
    data_dir_path = os.path.join(settings.STATIC_ROOT, 'data')
    context_dict['csv_list'] = os.listdir(data_dir_path)
    #########################################
    # family lists
    f_dict = {}
    '''
    for item in Family.objects.all():
        f_dict[item.name] = Malware.objects.filter(tags__icontains=item.name).count()
    '''

    context_dict['family_dict'] = Family.objects.all()

    #########################################
    # get file type
    tmp_list = Malware.objects.all().values("file_type").distinct()
    chart_sample_by_mime_type_data = []
    for item in tmp_list:
        chart_sample_by_mime_type_data.append([str(item['file_type']), 
            Malware.objects.filter(file_type=item['file_type']).count()])

    chart_sample_by_mime_type = Chart('PieChart', 
        chart_sample_by_mime_type_data, 
        'chart_sample_by_mime_type', 
        'Pie chart of malware by MIME type')

    context_dict['chart_sample_by_mime_type'] = chart_sample_by_mime_type
    
    #########################################
    tmp_list = Malware.objects.all().values("honeypot").distinct()
    chart_sample_by_honeypot_data = []
    for item in tmp_list:
        chart_sample_by_honeypot_data.append([str(item['honeypot']), 
            Malware.objects.filter(honeypot=item['honeypot']).count()])

    chart_sample_by_honeypot = Chart('PieChart', 
        chart_sample_by_honeypot_data, 
        'chart_sample_by_honeypot', 
        'Pie chart of malware by source')

    context_dict['chart_sample_by_honeypot'] = chart_sample_by_honeypot
    #########################################
    chart_sample_by_freshness_data = []
    chart_sample_by_freshness_data.append(['new sample', 
        Malware.objects.filter(is_new=True).count()])
    chart_sample_by_freshness_data.append(['old sample', 
        Malware.objects.filter(is_new=False).count()])
    chart_sample_by_freshness = Chart('PieChart', 
        chart_sample_by_freshness_data, 
        'chart_sample_by_freshness', 
        'Pie chart of malware by freshness')
    context_dict['chart_sample_by_freshness'] = chart_sample_by_freshness


    # Render the response and send it back!
    return render(request, 'stats.html', context_dict)


# Use the login_required() decorator to ensure only those logged in can access the view.
@login_required
def user_logout(request):
    # Since we know the user is logged in, we can now just log them out.
    logout(request)

    # Take the user back to the homepage.
    return HttpResponseRedirect('/login/')

def user_login(request):
    # Like before, obtain the context for the user's request.
    context = RequestContext(request)

    # If the request is a HTTP POST, try to pull out the relevant information.
    if request.method == 'POST':
        # Gather the username and password provided by the user.
        # This information is obtained from the login form.
        username = request.POST['username']
        password = request.POST['password']
        #form = CaptchaTestForm(request.POST)

        '''
        if form.is_valid():
            human = True
        else:
            #form = CaptchaTestForm()
            print 'not a human'
            form = CaptchaTestForm()
            return render_to_response('login.html', {'msg': 'In correct Captcha code!', 'form': form}, context)
        '''

        # Use Django's machinery to attempt to see if the username/password
        # combination is valid - a User object is returned if it is.
        user = authenticate(username=username, password=password)

        # If we have a User object, the details are correct.
        # If None (Python's way of representing the absence of a value), no user
        # with matching credentials was found.
        if user:
            # Is the account active? It could have been disabled.
            if user.is_active:
                # If the account is valid and active, we can log the user in.
                # We'll send the user back to the homepage.
                login(request, user)
                return HttpResponseRedirect('/')
            else:
                # An inactive account was used - no logging in!
                msg = "An inactive account was used - no logging in!"
                form = CaptchaTestForm()
                return render_to_response('login.html', {'msg':msg, 'form': form}, context)
        else:
            # Bad login details were provided. So we can't log the user in.
            print "Invalid login details: {0}, {1}".format(username, password)
            msg = "Invalid login credentials!"
            form = CaptchaTestForm()
            #print msg
            return render_to_response('login.html', {'msg':msg, 'form': form}, context)

    # The request is not a HTTP POST, so display the login form.
    # This scenario would most likely be a HTTP GET.
    else:
        # No context variables to pass to the template system, hence the
        # blank dictionary object...
        form = CaptchaTestForm()
        return render_to_response('login.html', {'form': form}, context)

def bad_state(msg, context):
    return render_to_response('bad_state.html', {'msg':msg}, context)








